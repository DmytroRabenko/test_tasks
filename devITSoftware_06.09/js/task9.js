/*
9.  Напишите функцию `add`, которая бы работала следующим образом `add(1)(2)(7)...(n)`. 
Количество последовательных визовов неограничено.

Пример:

Number(add(1)(2)); // == 3
Number(add(1)(2)(5)); // == 8
Number(add(1)(2)(-3)(4)); //  == 4
Number(add(1)(2)(3)(4)(-5)); // == 5
*/

function add(x) {   // Внутрішня функція, яка буде повертатися при кожному виклику add
    
    function nextAdd(y) {   // Сумуються аргументи і повертається нова функцію nextAdd
        return add(x + y);
    }
    
    nextAdd.valueOf = function() {  // Перетворення функції nextAdd на примітивний тип Number, який має властивість valueOf
      return x;
    };
  
    return nextAdd;
}


console.log(Number(add(1)(2)));                 // 3
console.log(Number(add(1)(2)(5)));              // 8
console.log(Number(add(1)(2)(-3)(4)));          // 4
console.log(Number(add(1)(2)(3)(4)(-5)(2)));    // 5

/*
Ідея вирішення полягає в тому, щоб кожен виклик функції add повертав нову функцію, 
яка очікує наступний аргумент. Коли викликається остання функцію зі значенням аргументу,  
обчислюється сума всіх аргументів і повертається результат.

Функція add, приймає початковий аргумент x. При кожному виклику вона буде повертати 
нову функцію nextAdd, яка очікує наступний аргумент y.

Функція nextAdd(y) додає x і y і повертає результат у вигляді нової функції add, якщо вона була викликана 
з аргументом. Це дозволяє нам продовжувати ланцюг викликів, додаючи нові аргументи до суми.
  
Для того щоб завершити ланцюг і отримати результат, ми перетворюємо функцію nextAdd на примітивний тип 
Number. Ми перевизначаємо метод valueOf об'єкта-функції nextAdd, який повертає значення x.
  
При виклику Number(add(...)) ми отримуємо суму всіх аргументів, які були додані в ланцюгу викликів, і 
отримуємо кінцевий результат.
  
У прикладах використання ми демонструємо, як можна викликати функцію add послідовно з різними аргументами, 
і в кінці отримати правильний результат суми.
*/