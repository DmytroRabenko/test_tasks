/*
9.  Напишите функцию `add`, которая бы работала следующим образом `add(1)(2)(7)...(n)`. 
Количество последовательных визовов неограничено.

Пример:

Number(add(1)(2)); // == 3
Number(add(1)(2)(5)); // == 8
Number(add(1)(2)(-3)(4)); //  == 4
Number(add(1)(2)(3)(4)(-5)); // == 5
*/

function add(x) {   // Внутрішня функція, яка буде повертатися при кожному виклику add
    
    function nextAdd(y) {   // Сумуються аргументи і повертається нова функцію nextAdd
        return add(x + y);
    }
    nextAdd.valueOf = function() {  //Перетворення в числове значення. 
      return x;
    };
  
    return nextAdd;
}


console.log(Number(add(1)(2)));                 // 3
console.log(Number(add(1)(2)(5)));              // 8
console.log(Number(add(1)(2)(-3)(4)));          // 4
console.log(Number(add(1)(2)(3)(4)(-5)));       // 5

/*
Ідея вирішення полягає в тому, щоб кожен виклик функції add повертав нову функцію, 
яка очікує наступний аргумент. Коли викликається остання функція зі значенням аргументу,  
обчислюється сума всіх аргументів і повертається результат.

Функція add, приймає початковий аргумент x. При кожному виклику вона буде повертати 
нову функцію nextAdd, яка очікує наступний аргумент y.

Функція nextAdd(y) додає x і y і повертає результат у вигляді нової функції add, якщо вона була викликана 
з аргументом. Це продовжувати виклики, додаючи нові аргументи до суми.
  
Для того щоб завершити виклики і отримати результат, ми перетворюємо функцію nextAdd на примітивний тип 
Number. Метод valueOf об'єкта-функції nextAdd, повертає значення x.
  
При виклику Number(add(...)) ми отримуємо суму всіх аргументів, які були додані в викликах, і 
отримуємо кінцевий результат.
*/