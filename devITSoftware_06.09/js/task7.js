/*
Напишите функцию, которая берет объект любой вложенности и преобразует ее в единую плоскую карту 
с разными уровнями, разделенными косой чертой ( `'/'`).

Пример:

const obj = {
  a: {
    b: {
      c: 12,
      d: 'Hello World'
    },
    e: [1,2,3]
  }
};

mapObject(demoData);
// Outputs: {
  'a/b/c': 12,
  'a/b/d': 'Hello World',
  'a/e': [1,2,3]
}

*/



function mapObject(obj, parentKey = '', result = {}) {

    for (const key in obj) {    //Цикл для передобу обєкта по ключах
      const value = obj[key];   //Для кожного ключа ми отримую відповідне значення value.
      const newKey = parentKey ? `${parentKey}/${key}` : key;   // Створюємо новий ключ
  
      if (typeof value === 'object' && !Array.isArray(value)) { // Якщо значення є об'єктом, викликаємо функцію рекурсивно для цього об'єкта зі збереженням нового ключа.
        mapObject(value, newKey, result);
      } else {
        // Якщо значення не є об'єктом, просто призначаємо його новому ключу в результаті.
        result[newKey] = value;
      }
    }
  
    return result; // Повертаємо результат виконання функції
}
  

const obj = {
    a: {
      b: {
        c: 12,
        d: 'Hello World'
      },
      e: [1,2,3]
    }
};
  

console.log(mapObject(obj));
  

/*
Функція mapObject приймає об'єкт obj для обробки, parentKey для відстеження батьківського ключа 
(використовується для утворення нового ключа) та result для зберігання результатів.

За допомогою циклу for in перебираємо обєкт.

Для кожного ключа отримуємо відповідне значення value.

Створюємо новий ключ newKey, який складається з батьківського ключа parentKey, якщо він є, 
та поточного ключа key, розділених косою лінією.

Перевіряємо, чи значення value є об'єктом і не є масивом. Якщо це так, викликаємо функцію mapObject 
рекурсивно для цього об'єкта з новим ключем newKey. Це дозволяє обробляти вкладені об'єкти.
В іншому випадку просто призначаємо значення value новому ключу newKey в об'єкті result.

Повертається результат виконання функції;
*/